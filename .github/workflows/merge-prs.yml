name: "Manual: Merge approved PRs (agent)"

on:
  workflow_dispatch:

permissions:
  contents: write        # needed to create merge commits on main
  pull-requests: write   # needed to call the Merge PR API
  checks: read
  actions: read

jobs:
  merge-sequence:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (not strictly required for API merges, but useful for logs)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Confirm run metadata
        run: |
          echo "Repository: ${{ github.repository }}"
          echo "Actor: ${{ github.actor }}"
          echo "Run ID: ${{ github.run_id }}"

      - name: Merge PRs in approved order
        id: merge_prs
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Config: change these if you want a different order or different strategy
            const repoOwner = context.repo.owner;
            const repoName = context.repo.repo;

            // Approved defaults from user: merge method = "merge", stop on conflicts
            const prOrder = [40, 41, 39, 36];
            const mergeMethod = "merge"; // options: "merge", "squash", "rebase"

            console.log(`Merging PRs in order: ${prOrder.join(", ")}`);
            for (const prNum of prOrder) {
              core.info(`Attempting to merge PR #${prNum}...`);

              // Get PR metadata
              const { data: pr } = await github.rest.pulls.get({
                owner: repoOwner,
                repo: repoName,
                pull_number: prNum,
              });

              if (pr.state !== "open") {
                core.info(`PR #${prNum} is not open (state=${pr.state}); skipping.`);
                continue;
              }

              // Attempt merge (this will fail with 405 or 409 if not mergeable or conflict)
              try {
                const mergeResponse = await github.rest.pulls.merge({
                  owner: repoOwner,
                  repo: repoName,
                  pull_number: prNum,
                  merge_method: mergeMethod,
                });

                if (mergeResponse.data.merged) {
                  core.info(`âœ… PR #${prNum} merged successfully. SHA: ${mergeResponse.data.sha}`);
                } else {
                  // If API returns merged=false, surface message and stop (per defaults)
                  core.setFailed(`PR #${prNum} not merged: ${JSON.stringify(mergeResponse.data)}`);
                }
              } catch (err) {
                // Stop on conflicts/errors as requested
                core.error(`Failed to merge PR #${prNum}: ${err.message}`);
                // Try to provide a helpful reason if the API supplies it
                if (err.status === 405 || err.status === 409) {
                  core.setFailed(`Merge blocked for PR #${prNum} (status ${err.status}). This likely indicates merge conflicts or that the branch is out-of-date/isn't mergeable. See PR ${pr.html_url} for details.`);
                } else {
                  core.setFailed(`Unexpected error merging PR #${prNum}: ${err}`);
                }
                throw err; // stop the job immediately as you requested
              }
            }

      - name: Report success
        if: success()
        run: echo "All PRs in the approved order were merged successfully."
